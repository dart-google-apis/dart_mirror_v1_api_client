part of mirror_v1_api_client;

/** Represents media content, such as a photo, that can be attached to a timeline item. */
class Attachment {

  /** The MIME type of the attachment. */
  core.String contentType;

  /** The URL for the content. */
  core.String contentUrl;

  /** The ID of the attachment. */
  core.String id;

  /** Indicates that the contentUrl is not available because the attachment content is still being processed. If the caller wishes to retrieve the content, it should try again later. */
  core.bool isProcessingContent;

  /** Create new Attachment from JSON data */
  Attachment.fromJson(core.Map json) {
    if (json.containsKey("contentType")) {
      contentType = json["contentType"];
    }
    if (json.containsKey("contentUrl")) {
      contentUrl = json["contentUrl"];
    }
    if (json.containsKey("id")) {
      id = json["id"];
    }
    if (json.containsKey("isProcessingContent")) {
      isProcessingContent = json["isProcessingContent"];
    }
  }

  /** Create JSON Object for Attachment */
  core.Map toJson() {
    var output = new core.Map();

    if (contentType != null) {
      output["contentType"] = contentType;
    }
    if (contentUrl != null) {
      output["contentUrl"] = contentUrl;
    }
    if (id != null) {
      output["id"] = id;
    }
    if (isProcessingContent != null) {
      output["isProcessingContent"] = isProcessingContent;
    }

    return output;
  }

  /** Return String representation of Attachment */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A list of Attachments. This is the response from the server to GET requests on the attachments collection. */
class AttachmentsListResponse {

  /** The list of attachments. */
  core.List<Attachment> items;

  /** The type of resource. This is always mirror#attachmentsList. */
  core.String kind;

  /** Create new AttachmentsListResponse from JSON data */
  AttachmentsListResponse.fromJson(core.Map json) {
    if (json.containsKey("items")) {
      items = [];
      json["items"].forEach((item) {
        items.add(new Attachment.fromJson(item));
      });
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
  }

  /** Create JSON Object for AttachmentsListResponse */
  core.Map toJson() {
    var output = new core.Map();

    if (items != null) {
      output["items"] = new core.List();
      items.forEach((item) {
        output["items"].add(item.toJson());
      });
    }
    if (kind != null) {
      output["kind"] = kind;
    }

    return output;
  }

  /** Return String representation of AttachmentsListResponse */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A person or group that can be used as a creator or a contact. */
class Contact {

  /** A list of MIME types that a contact can handle. The contact will be shown to the user if any of its acceptTypes matches any of the types of the attachments on the item. If no acceptTypes are given, the contact will be shown for all items. A list of MIME types that a contact supports. The contact will be shown to the user if any of its acceptTypes matches any of the types of the attachments on the item. If no acceptTypes are given, the contact will be shown for all items. */
  core.List<core.String> acceptTypes;

  /** The name to display for this contact. */
  core.String displayName;

  /** EXPERIMENTAL: Do not use externally. Primary email for the contact. */
  core.String email;

  /** An ID for this contact. This is generated by the application and is treated as an opaque token. */
  core.String id;

  /** Set of image URLs to display for a contact. Most contacts will have a single image, but a "group" contact may include up to 8 image URLs and they will be re-sized and cropped into a mosaic on the client. Set of image URLs to display for a contact. Most contacts will have a single image, but a "group" contact may include up to 8 image URLs and they will be resized and cropped into a mosaic on the client. */
  core.List<core.String> imageUrls;

  /** The type of resource. This is always mirror#contact. */
  core.String kind;

  /** Primary phone number for the contact. This can be a fully-qualified number, with country calling code and area code or a local number. Primary phone number for the contact. This can be a fully-qualified number, with country calling code and area code, or a local number. */
  core.String phoneNumber;

  /** Priority for the contact to determine ordering in a list of contacts. Contacts with higher priorities will be shown before ones with lower priorities. */
  core.int priority;

  /** EXPERIMENTAL: Do not use externally. Set of secondary emails for the contact. */
  core.List<core.String> secondaryEmails;

  /** EXPERIMENTAL: Do not use externally. Set of secondary phone numbers for the contact. See phoneNumber. */
  core.List<core.String> secondaryPhoneNumbers;

  /** The ID of the application that created this contact. This is populated by the API */
  core.String source;

  /** The type for this contact. This is used for sorting in UIs. Allowed values are:  
- INDIVIDUAL - Represents a single person. This is the default. 
- GROUP - Represents more than a single person. */
  core.String type;

  /** Create new Contact from JSON data */
  Contact.fromJson(core.Map json) {
    if (json.containsKey("acceptTypes")) {
      acceptTypes = [];
      json["acceptTypes"].forEach((item) {
        acceptTypes.add(item);
      });
    }
    if (json.containsKey("displayName")) {
      displayName = json["displayName"];
    }
    if (json.containsKey("email")) {
      email = json["email"];
    }
    if (json.containsKey("id")) {
      id = json["id"];
    }
    if (json.containsKey("imageUrls")) {
      imageUrls = [];
      json["imageUrls"].forEach((item) {
        imageUrls.add(item);
      });
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
    if (json.containsKey("phoneNumber")) {
      phoneNumber = json["phoneNumber"];
    }
    if (json.containsKey("priority")) {
      priority = json["priority"];
    }
    if (json.containsKey("secondaryEmails")) {
      secondaryEmails = [];
      json["secondaryEmails"].forEach((item) {
        secondaryEmails.add(item);
      });
    }
    if (json.containsKey("secondaryPhoneNumbers")) {
      secondaryPhoneNumbers = [];
      json["secondaryPhoneNumbers"].forEach((item) {
        secondaryPhoneNumbers.add(item);
      });
    }
    if (json.containsKey("source")) {
      source = json["source"];
    }
    if (json.containsKey("type")) {
      type = json["type"];
    }
  }

  /** Create JSON Object for Contact */
  core.Map toJson() {
    var output = new core.Map();

    if (acceptTypes != null) {
      output["acceptTypes"] = new core.List();
      acceptTypes.forEach((item) {
        output["acceptTypes"].add(item);
      });
    }
    if (displayName != null) {
      output["displayName"] = displayName;
    }
    if (email != null) {
      output["email"] = email;
    }
    if (id != null) {
      output["id"] = id;
    }
    if (imageUrls != null) {
      output["imageUrls"] = new core.List();
      imageUrls.forEach((item) {
        output["imageUrls"].add(item);
      });
    }
    if (kind != null) {
      output["kind"] = kind;
    }
    if (phoneNumber != null) {
      output["phoneNumber"] = phoneNumber;
    }
    if (priority != null) {
      output["priority"] = priority;
    }
    if (secondaryEmails != null) {
      output["secondaryEmails"] = new core.List();
      secondaryEmails.forEach((item) {
        output["secondaryEmails"].add(item);
      });
    }
    if (secondaryPhoneNumbers != null) {
      output["secondaryPhoneNumbers"] = new core.List();
      secondaryPhoneNumbers.forEach((item) {
        output["secondaryPhoneNumbers"].add(item);
      });
    }
    if (source != null) {
      output["source"] = source;
    }
    if (type != null) {
      output["type"] = type;
    }

    return output;
  }

  /** Return String representation of Contact */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A list of Contacts representing contacts. This is the response from the server to GET requests on the contacts collection. */
class ContactsListResponse {

  /** Contact list. */
  core.List<Contact> items;

  /** The type of resource. This is always mirror#contacts. */
  core.String kind;

  /** Create new ContactsListResponse from JSON data */
  ContactsListResponse.fromJson(core.Map json) {
    if (json.containsKey("items")) {
      items = [];
      json["items"].forEach((item) {
        items.add(new Contact.fromJson(item));
      });
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
  }

  /** Create JSON Object for ContactsListResponse */
  core.Map toJson() {
    var output = new core.Map();

    if (items != null) {
      output["items"] = new core.List();
      items.forEach((item) {
        output["items"].add(item.toJson());
      });
    }
    if (kind != null) {
      output["kind"] = kind;
    }

    return output;
  }

  /** Return String representation of ContactsListResponse */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A geographic location that can be associated with a timeline item. */
class Location {

  /** The accuracy of the location fix in meters. */
  core.num accuracy;

  /** The full address of the location. */
  core.String address;

  /** The name to be displayed. This may be a business name or a user-defined place, such as "Home". */
  core.String displayName;

  /** The ID of the location. */
  core.String id;

  /** The type of resource. This is always mirror#location. */
  core.String kind;

  /** The latitude, in degrees. */
  core.num latitude;

  /** The longitude, in degrees. */
  core.num longitude;

  /** The time at which this location was captured, formatted according to RFC 3339. */
  core.String timestamp;

  /** Create new Location from JSON data */
  Location.fromJson(core.Map json) {
    if (json.containsKey("accuracy")) {
      accuracy = json["accuracy"];
    }
    if (json.containsKey("address")) {
      address = json["address"];
    }
    if (json.containsKey("displayName")) {
      displayName = json["displayName"];
    }
    if (json.containsKey("id")) {
      id = json["id"];
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
    if (json.containsKey("latitude")) {
      latitude = json["latitude"];
    }
    if (json.containsKey("longitude")) {
      longitude = json["longitude"];
    }
    if (json.containsKey("timestamp")) {
      timestamp = json["timestamp"];
    }
  }

  /** Create JSON Object for Location */
  core.Map toJson() {
    var output = new core.Map();

    if (accuracy != null) {
      output["accuracy"] = accuracy;
    }
    if (address != null) {
      output["address"] = address;
    }
    if (displayName != null) {
      output["displayName"] = displayName;
    }
    if (id != null) {
      output["id"] = id;
    }
    if (kind != null) {
      output["kind"] = kind;
    }
    if (latitude != null) {
      output["latitude"] = latitude;
    }
    if (longitude != null) {
      output["longitude"] = longitude;
    }
    if (timestamp != null) {
      output["timestamp"] = timestamp;
    }

    return output;
  }

  /** Return String representation of Location */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A list of Locations. This is the response from the server to GET requests on the locations collection. */
class LocationsListResponse {

  /** The list of locations. */
  core.List<Location> items;

  /** The type of resource. This is always mirror#locationsList. */
  core.String kind;

  /** Create new LocationsListResponse from JSON data */
  LocationsListResponse.fromJson(core.Map json) {
    if (json.containsKey("items")) {
      items = [];
      json["items"].forEach((item) {
        items.add(new Location.fromJson(item));
      });
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
  }

  /** Create JSON Object for LocationsListResponse */
  core.Map toJson() {
    var output = new core.Map();

    if (items != null) {
      output["items"] = new core.List();
      items.forEach((item) {
        output["items"].add(item.toJson());
      });
    }
    if (kind != null) {
      output["kind"] = kind;
    }

    return output;
  }

  /** Return String representation of LocationsListResponse */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A custom menu item that can be presented to the user by a timeline item. */
class MenuItem {

  /** Controls the behavior when the user picks the menu option. Allowed values are:  
- CUSTOM - Custom action set by the service. When the user selects this menuItem, the API triggers a notification to your callbackUrl with the userActions.type set to CUSTOM and the userActions.payload set to the ID of this menu item. This is the default value. 
- Built-in actions:  
- REPLY - Initiate a reply to the timeline item using the voice recording UI. The creator attribute must be set in the timeline item for this menu to be available. 
- REPLY_ALL - Same behavior as REPLY. The original timeline item's recipients will be added to the reply item. 
- DELETE - Delete the timeline item. 
- SHARE - Share the timeline item with the available contacts. 
- READ_ALOUD - Read the timeline item's speakableText aloud; if this field is not set, read the text field; if none of those fields are set, this menu item is ignored.  
- VOICE_CALL - Initiate a phone call using the timeline item's creator.phone_number attribute as recipient. 
- NAVIGATE - Navigate to the timeline item's location. 
- TOGGLE_PINNED - Toggle the isPinned state of the timeline item. */
  core.String action;

  /** The ID for this menu item. This is generated by the application and is treated as an opaque token. */
  core.String id;

  /** If set to true on a CUSTOM menu item, that item will be removed from the menu after it is selected. */
  core.bool removeWhenSelected;

  /** For CUSTOM items, a list of values controlling the appearance of the menu item in each of its states. A value for the DEFAULT state must be provided. If the PENDING or CONFIRMED states are missing, they will not be shown. */
  core.List<MenuValue> values;

  /** Create new MenuItem from JSON data */
  MenuItem.fromJson(core.Map json) {
    if (json.containsKey("action")) {
      action = json["action"];
    }
    if (json.containsKey("id")) {
      id = json["id"];
    }
    if (json.containsKey("removeWhenSelected")) {
      removeWhenSelected = json["removeWhenSelected"];
    }
    if (json.containsKey("values")) {
      values = [];
      json["values"].forEach((item) {
        values.add(new MenuValue.fromJson(item));
      });
    }
  }

  /** Create JSON Object for MenuItem */
  core.Map toJson() {
    var output = new core.Map();

    if (action != null) {
      output["action"] = action;
    }
    if (id != null) {
      output["id"] = id;
    }
    if (removeWhenSelected != null) {
      output["removeWhenSelected"] = removeWhenSelected;
    }
    if (values != null) {
      output["values"] = new core.List();
      values.forEach((item) {
        output["values"].add(item.toJson());
      });
    }

    return output;
  }

  /** Return String representation of MenuItem */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A single value that is part of a MenuItem. */
class MenuValue {

  /** The name to display for the menu item. */
  core.String displayName;

  /** URL of an icon to display with the menu item. */
  core.String iconUrl;

  /** The state that this value applies to. Allowed values are:  
- DEFAULT - Default value shown when displayed in the menuItems list. 
- PENDING - Value shown when the menuItem has been selected by the user but can still be cancelled. 
- CONFIRMED - Value shown when the menuItem has been selected by the user and can no longer be cancelled. */
  core.String state;

  /** Create new MenuValue from JSON data */
  MenuValue.fromJson(core.Map json) {
    if (json.containsKey("displayName")) {
      displayName = json["displayName"];
    }
    if (json.containsKey("iconUrl")) {
      iconUrl = json["iconUrl"];
    }
    if (json.containsKey("state")) {
      state = json["state"];
    }
  }

  /** Create JSON Object for MenuValue */
  core.Map toJson() {
    var output = new core.Map();

    if (displayName != null) {
      output["displayName"] = displayName;
    }
    if (iconUrl != null) {
      output["iconUrl"] = iconUrl;
    }
    if (state != null) {
      output["state"] = state;
    }

    return output;
  }

  /** Return String representation of MenuValue */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A notification delivered by the API. */
class Notification {

  /** The collection that generated the notification. */
  core.String collection;

  /** The ID of the item that generated the notification. */
  core.String itemId;

  /** The type of operation that generated the notification. */
  core.String operation;

  /** A list of actions taken by the user that triggered the notification. */
  core.List<UserAction> userActions;

  /** The user token provided by the service when it subscribed for notifications. */
  core.String userToken;

  /** The secret verify token provided by the service when it subscribed for notifications. */
  core.String verifyToken;

  /** Create new Notification from JSON data */
  Notification.fromJson(core.Map json) {
    if (json.containsKey("collection")) {
      collection = json["collection"];
    }
    if (json.containsKey("itemId")) {
      itemId = json["itemId"];
    }
    if (json.containsKey("operation")) {
      operation = json["operation"];
    }
    if (json.containsKey("userActions")) {
      userActions = [];
      json["userActions"].forEach((item) {
        userActions.add(new UserAction.fromJson(item));
      });
    }
    if (json.containsKey("userToken")) {
      userToken = json["userToken"];
    }
    if (json.containsKey("verifyToken")) {
      verifyToken = json["verifyToken"];
    }
  }

  /** Create JSON Object for Notification */
  core.Map toJson() {
    var output = new core.Map();

    if (collection != null) {
      output["collection"] = collection;
    }
    if (itemId != null) {
      output["itemId"] = itemId;
    }
    if (operation != null) {
      output["operation"] = operation;
    }
    if (userActions != null) {
      output["userActions"] = new core.List();
      userActions.forEach((item) {
        output["userActions"].add(item.toJson());
      });
    }
    if (userToken != null) {
      output["userToken"] = userToken;
    }
    if (verifyToken != null) {
      output["verifyToken"] = verifyToken;
    }

    return output;
  }

  /** Return String representation of Notification */
  core.String toString() => JSON.stringify(this.toJson());

}

/** Controls how notifications for a timeline item are presented to the user. */
class NotificationConfig {

  /** The time at which the notification should be delivered. */
  core.String deliveryTime;

  /** Describes how important the notification is. Allowed values are:  
- DEFAULT - Notifications of default importance. A chime will be played to alert users. */
  core.String level;

  /** Create new NotificationConfig from JSON data */
  NotificationConfig.fromJson(core.Map json) {
    if (json.containsKey("deliveryTime")) {
      deliveryTime = json["deliveryTime"];
    }
    if (json.containsKey("level")) {
      level = json["level"];
    }
  }

  /** Create JSON Object for NotificationConfig */
  core.Map toJson() {
    var output = new core.Map();

    if (deliveryTime != null) {
      output["deliveryTime"] = deliveryTime;
    }
    if (level != null) {
      output["level"] = level;
    }

    return output;
  }

  /** Return String representation of NotificationConfig */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A subscription to events on a collection. */
class Subscription {

  /** The URL where notifications should be delivered (must start with https://). */
  core.String callbackUrl;

  /** The collection to subscribe to. Allowed values are:  
- timeline - Changes in the timeline including insertion, deletion, and updates. 
- locations - Location updates. */
  core.String collection;

  /** The ID of the subscription. */
  core.String id;

  /** The type of resource. This is always mirror#subscription. */
  core.String kind;

  /** Container object for notifications. This is not populated in the Subscription resource. */
  Notification notification;

  /** A list of operations that should be subscribed to. An empty list indicates that all operations on the collection should be subscribed to. Allowed values are:  
- UPDATE - The item has been updated. 
- INSERT - A new item has been inserted. 
- DELETE - The item has been deleted. 
- MENU_ACTION - A custom menu item has been triggered by the user. */
  core.List<core.String> operation;

  /** The time at which this subscription was last modified, formatted according to RFC 3339. */
  core.String updated;

  /** An opaque token sent to the subscriber in notifications so that it can determine the ID of the user. */
  core.String userToken;

  /** A secret token sent to the subscriber in notifications so that it can verify that the notification was generated by Google. */
  core.String verifyToken;

  /** Create new Subscription from JSON data */
  Subscription.fromJson(core.Map json) {
    if (json.containsKey("callbackUrl")) {
      callbackUrl = json["callbackUrl"];
    }
    if (json.containsKey("collection")) {
      collection = json["collection"];
    }
    if (json.containsKey("id")) {
      id = json["id"];
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
    if (json.containsKey("notification")) {
      notification = new Notification.fromJson(json["notification"]);
    }
    if (json.containsKey("operation")) {
      operation = [];
      json["operation"].forEach((item) {
        operation.add(item);
      });
    }
    if (json.containsKey("updated")) {
      updated = json["updated"];
    }
    if (json.containsKey("userToken")) {
      userToken = json["userToken"];
    }
    if (json.containsKey("verifyToken")) {
      verifyToken = json["verifyToken"];
    }
  }

  /** Create JSON Object for Subscription */
  core.Map toJson() {
    var output = new core.Map();

    if (callbackUrl != null) {
      output["callbackUrl"] = callbackUrl;
    }
    if (collection != null) {
      output["collection"] = collection;
    }
    if (id != null) {
      output["id"] = id;
    }
    if (kind != null) {
      output["kind"] = kind;
    }
    if (notification != null) {
      output["notification"] = notification.toJson();
    }
    if (operation != null) {
      output["operation"] = new core.List();
      operation.forEach((item) {
        output["operation"].add(item);
      });
    }
    if (updated != null) {
      output["updated"] = updated;
    }
    if (userToken != null) {
      output["userToken"] = userToken;
    }
    if (verifyToken != null) {
      output["verifyToken"] = verifyToken;
    }

    return output;
  }

  /** Return String representation of Subscription */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A list of Subscriptions. This is the response from the server to GET requests on the subscription collection. */
class SubscriptionsListResponse {

  /** The list of subscriptions. */
  core.List<Subscription> items;

  /** The type of resource. This is always mirror#subscriptionsList. */
  core.String kind;

  /** Create new SubscriptionsListResponse from JSON data */
  SubscriptionsListResponse.fromJson(core.Map json) {
    if (json.containsKey("items")) {
      items = [];
      json["items"].forEach((item) {
        items.add(new Subscription.fromJson(item));
      });
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
  }

  /** Create JSON Object for SubscriptionsListResponse */
  core.Map toJson() {
    var output = new core.Map();

    if (items != null) {
      output["items"] = new core.List();
      items.forEach((item) {
        output["items"].add(item.toJson());
      });
    }
    if (kind != null) {
      output["kind"] = kind;
    }

    return output;
  }

  /** Return String representation of SubscriptionsListResponse */
  core.String toString() => JSON.stringify(this.toJson());

}

/** Each item in the user's timeline is represented as a TimelineItem JSON structure, described below. */
class TimelineItem {

  /** A list of media attachments associated with this item. */
  core.List<Attachment> attachments;

  /** The bundle ID for this item. Services can specify a bundleId to group many items together. They appear under a single top-level item on the device. */
  core.String bundleId;

  /** A canonical URL pointing to the canonical/high quality version of the data represented by the timeline item. */
  core.String canonicalUrl;

  /** The time at which this item was created, formatted according to RFC 3339. */
  core.String created;

  /** The user or group that created this item. */
  Contact creator;

  /** The time that should be displayed when this item is viewed in the timeline, formatted according to RFC 3339. This user's timeline is sorted chronologically on display time, so this will also determine where the item is displayed in the timeline. If not set by the service, the display time defaults to the updated time. */
  core.String displayTime;

  /** ETag for this item. */
  core.String etag;

  /** HTML content for this item. If both text and html are provided for an item, the html will be rendered in the timeline. */
  core.String html;

  /** Additional pages of HTML content associated with this item. If this field is specified, the item will be displayed as a bundle, with the html field as the cover. It is an error to specify this field without specifying the html field. */
  core.List<core.String> htmlPages;

  /** The ID of the timeline item. This is unique within a user's timeline. */
  core.String id;

  /** If this item was generated as a reply to another item, this field will be set to the ID of the item being replied to. This can be used to attach a reply to the appropriate conversation or post. */
  core.String inReplyTo;

  /** Whether this item is a bundle cover.

If an item is marked as a bundle cover, it will be the entry point to the bundle of items that have the same bundleId as that item. It will be shown only on the main timeline â not within the opened bundle.

On the main timeline, items that are shown are:  
- Items that have isBundleCover set to true  
- Items that do not have a bundleId  In a bundle sub-timeline, items that are shown are:  
- Items that have the bundleId in question AND isBundleCover set to false */
  core.bool isBundleCover;

  /** When true, indicates this item is deleted, and only the ID property is set. */
  core.bool isDeleted;

  /** When true, indicates this item is pinned, which means it's grouped alongside "active" items like navigation and hangouts, on the opposite side of the home screen from historical (non-pinned) timeline items. */
  core.bool isPinned;

  /** The type of resource. This is always mirror#timelineItem. */
  core.String kind;

  /** The geographic location associated with this item. */
  Location location;

  /** A list of menu items that will be presented to the user when this item is selected in the timeline. */
  core.List<MenuItem> menuItems;

  /** Controls how notifications for this item are presented on the device. If this is missing, no notification will be generated. */
  NotificationConfig notification;

  /** For pinned items, this determines the order in which the item is displayed in the timeline, with a higher score appearing closer to the clock. Note: setting this field is currently not supported. */
  core.int pinScore;

  /** A list of users or groups that this item has been shared with. */
  core.List<Contact> recipients;

  /** A URL that can be used to retrieve this item. */
  core.String selfLink;

  /** Opaque string you can use to map a timeline item to data in your own service. */
  core.String sourceItemId;

  /** The speakable version of the content of this item. Along with the READ_ALOUD menu item, use this field to provide text that would be clearer when read aloud, or to provide extended information to what is displayed visually on Glass. */
  core.String speakableText;

  /** Text content of this item. */
  core.String text;

  /** The title of this item. */
  core.String title;

  /** The time at which this item was last modified, formatted according to RFC 3339. */
  core.String updated;

  /** Create new TimelineItem from JSON data */
  TimelineItem.fromJson(core.Map json) {
    if (json.containsKey("attachments")) {
      attachments = [];
      json["attachments"].forEach((item) {
        attachments.add(new Attachment.fromJson(item));
      });
    }
    if (json.containsKey("bundleId")) {
      bundleId = json["bundleId"];
    }
    if (json.containsKey("canonicalUrl")) {
      canonicalUrl = json["canonicalUrl"];
    }
    if (json.containsKey("created")) {
      created = json["created"];
    }
    if (json.containsKey("creator")) {
      creator = new Contact.fromJson(json["creator"]);
    }
    if (json.containsKey("displayTime")) {
      displayTime = json["displayTime"];
    }
    if (json.containsKey("etag")) {
      etag = json["etag"];
    }
    if (json.containsKey("html")) {
      html = json["html"];
    }
    if (json.containsKey("htmlPages")) {
      htmlPages = [];
      json["htmlPages"].forEach((item) {
        htmlPages.add(item);
      });
    }
    if (json.containsKey("id")) {
      id = json["id"];
    }
    if (json.containsKey("inReplyTo")) {
      inReplyTo = json["inReplyTo"];
    }
    if (json.containsKey("isBundleCover")) {
      isBundleCover = json["isBundleCover"];
    }
    if (json.containsKey("isDeleted")) {
      isDeleted = json["isDeleted"];
    }
    if (json.containsKey("isPinned")) {
      isPinned = json["isPinned"];
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
    if (json.containsKey("location")) {
      location = new Location.fromJson(json["location"]);
    }
    if (json.containsKey("menuItems")) {
      menuItems = [];
      json["menuItems"].forEach((item) {
        menuItems.add(new MenuItem.fromJson(item));
      });
    }
    if (json.containsKey("notification")) {
      notification = new NotificationConfig.fromJson(json["notification"]);
    }
    if (json.containsKey("pinScore")) {
      pinScore = json["pinScore"];
    }
    if (json.containsKey("recipients")) {
      recipients = [];
      json["recipients"].forEach((item) {
        recipients.add(new Contact.fromJson(item));
      });
    }
    if (json.containsKey("selfLink")) {
      selfLink = json["selfLink"];
    }
    if (json.containsKey("sourceItemId")) {
      sourceItemId = json["sourceItemId"];
    }
    if (json.containsKey("speakableText")) {
      speakableText = json["speakableText"];
    }
    if (json.containsKey("text")) {
      text = json["text"];
    }
    if (json.containsKey("title")) {
      title = json["title"];
    }
    if (json.containsKey("updated")) {
      updated = json["updated"];
    }
  }

  /** Create JSON Object for TimelineItem */
  core.Map toJson() {
    var output = new core.Map();

    if (attachments != null) {
      output["attachments"] = new core.List();
      attachments.forEach((item) {
        output["attachments"].add(item.toJson());
      });
    }
    if (bundleId != null) {
      output["bundleId"] = bundleId;
    }
    if (canonicalUrl != null) {
      output["canonicalUrl"] = canonicalUrl;
    }
    if (created != null) {
      output["created"] = created;
    }
    if (creator != null) {
      output["creator"] = creator.toJson();
    }
    if (displayTime != null) {
      output["displayTime"] = displayTime;
    }
    if (etag != null) {
      output["etag"] = etag;
    }
    if (html != null) {
      output["html"] = html;
    }
    if (htmlPages != null) {
      output["htmlPages"] = new core.List();
      htmlPages.forEach((item) {
        output["htmlPages"].add(item);
      });
    }
    if (id != null) {
      output["id"] = id;
    }
    if (inReplyTo != null) {
      output["inReplyTo"] = inReplyTo;
    }
    if (isBundleCover != null) {
      output["isBundleCover"] = isBundleCover;
    }
    if (isDeleted != null) {
      output["isDeleted"] = isDeleted;
    }
    if (isPinned != null) {
      output["isPinned"] = isPinned;
    }
    if (kind != null) {
      output["kind"] = kind;
    }
    if (location != null) {
      output["location"] = location.toJson();
    }
    if (menuItems != null) {
      output["menuItems"] = new core.List();
      menuItems.forEach((item) {
        output["menuItems"].add(item.toJson());
      });
    }
    if (notification != null) {
      output["notification"] = notification.toJson();
    }
    if (pinScore != null) {
      output["pinScore"] = pinScore;
    }
    if (recipients != null) {
      output["recipients"] = new core.List();
      recipients.forEach((item) {
        output["recipients"].add(item.toJson());
      });
    }
    if (selfLink != null) {
      output["selfLink"] = selfLink;
    }
    if (sourceItemId != null) {
      output["sourceItemId"] = sourceItemId;
    }
    if (speakableText != null) {
      output["speakableText"] = speakableText;
    }
    if (text != null) {
      output["text"] = text;
    }
    if (title != null) {
      output["title"] = title;
    }
    if (updated != null) {
      output["updated"] = updated;
    }

    return output;
  }

  /** Return String representation of TimelineItem */
  core.String toString() => JSON.stringify(this.toJson());

}

/** A list of timeline items. This is the response from the server to GET requests on the timeline collection. */
class TimelineListResponse {

  /** Items in the timeline. */
  core.List<TimelineItem> items;

  /** The type of resource. This is always mirror#timeline. */
  core.String kind;

  /** The next page token. Provide this as the pageToken parameter in the request to retrieve the next page of results. */
  core.String nextPageToken;

  /** Create new TimelineListResponse from JSON data */
  TimelineListResponse.fromJson(core.Map json) {
    if (json.containsKey("items")) {
      items = [];
      json["items"].forEach((item) {
        items.add(new TimelineItem.fromJson(item));
      });
    }
    if (json.containsKey("kind")) {
      kind = json["kind"];
    }
    if (json.containsKey("nextPageToken")) {
      nextPageToken = json["nextPageToken"];
    }
  }

  /** Create JSON Object for TimelineListResponse */
  core.Map toJson() {
    var output = new core.Map();

    if (items != null) {
      output["items"] = new core.List();
      items.forEach((item) {
        output["items"].add(item.toJson());
      });
    }
    if (kind != null) {
      output["kind"] = kind;
    }
    if (nextPageToken != null) {
      output["nextPageToken"] = nextPageToken;
    }

    return output;
  }

  /** Return String representation of TimelineListResponse */
  core.String toString() => JSON.stringify(this.toJson());

}

/** Represents an action taken by the user that triggered a notification. */
class UserAction {

  /** An optional payload for the action.

For actions of type CUSTOM, this is the ID of the custom menu item that was selected. */
  core.String payload;

  /** The type of action. The value of this can be:  
- SHARE - the user shared an item. 
- REPLY - the user replied to an item. 
- REPLY_ALL - the user replied to all recipients of an item. 
- CUSTOM - the user selected a custom menu item on the timeline item. 
- DELETE - the user deleted the item. 
- PIN - the user pinned the item. 
- UNPIN - the user unpinned the item.  In the future, additional types may be added. UserActions with unrecognized types should be ignored. */
  core.String type;

  /** Create new UserAction from JSON data */
  UserAction.fromJson(core.Map json) {
    if (json.containsKey("payload")) {
      payload = json["payload"];
    }
    if (json.containsKey("type")) {
      type = json["type"];
    }
  }

  /** Create JSON Object for UserAction */
  core.Map toJson() {
    var output = new core.Map();

    if (payload != null) {
      output["payload"] = payload;
    }
    if (type != null) {
      output["type"] = type;
    }

    return output;
  }

  /** Return String representation of UserAction */
  core.String toString() => JSON.stringify(this.toJson());

}

